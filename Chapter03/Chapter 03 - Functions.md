# Functions:



- *Function declaration* uses **parameters**: parameters are just *local variables* inside the function def.

- *Function calls* passes ***arguments*** into the function.

- *Parameters* are <u>optional</u>.

- When used, parameters must have a *name* and *type*, separated by comma: `,`.

- *Arguments* passed into the function must be of the same *<u>order</u>* and *<u>type</u>* as the *parameters*.

  ```kotlin
  fun main() {
    printSum(2, 3)
  }
  
  fun printSum(int1: Int, int2: Int) {
    val result = int1 + int2
    println(result)
  }
  ```

  

- If you want to get something back from a function, it needs to be **declared**:

  ```kotlin
  fun man(a: Int, b: Int): Int {
    val maxValue = if (a > b) a else b
    return maxValue
  }
  ```

  - `Int`: after the constructor, tells the compiler that the function returns and *Integer*.
  - `return` keyword followed by the variable name or expression to return.
  - the returned variable/value type has to match the function's declared type.
  - **NOTE**: if a return type is explicitly declared, the function **has to ** include a `return` statement.

- If `return` wasn't required, either:

  - omit the *return type* from the function decleration, or

  - specify a return type of `Unit`: meaning the function returns no value.

    ```kotlin
    fun printSum(int1: Int, int2: Int) {
      val result = int1 + int2
      println(result)
    }
    ```
  
    ```kotlin
    // same as the above
    fun printSum(int1: Int, int2: Int): Unit { //this is optional
      val result = int1 + int2
      println(result)
    }
    ```
  
  - **NOTE**: if you try to return a value from a function with no declared return type, or a return type `Unit`, the **code will not compile**.



#### Functions with single expression bodies:

- a function with a single expression can be simplified by removing the *curly braces and return statement*:

  ```kotlin
  fun max(a: Int, b: Int): Int {
    val maxValue = if (a > b) a else b
    return maxValue
  }
  ```

  Can be written as:

  ```kotlin
  fun max(a: Int, b: Int) = if (a > b) a else b
  // = sign reads: returns 
  // return type is omitted due to compiler inference. 
  ```



### Create the `getGameChoice` function:

```kotlin
// accepts one parameter of the type Array<String> and returns one of the arrays items (String):
fun getGameChoice(optionsParam: Array<String>): String {
  val randomNumber = (Math.random() * optionsPara.size).toInt
  return optionsParam[randomNumber]
}

/*
 * the above can be simplified since the result can be achieved with one expression and without a return statment 
 * Although it'll work, ALWAYAS consider the readability of your code! The above example is more readable. 
 */

fun getGameChoic(optionsParam: Array<String>) = 
optionsParam[(Math.random() * optionsParam.size).toString]
```



Add it to Game.kt

```kotlin
fun main() {

    //  creates an array of Strings and stores a reference to it in variable Options
    val options = arrayOf("Rock", "paper", "Scissors")

    /*
     *  getGameChoice takes an array of Strings, options, as an argument and returns a random String.
     *  The reference to the random String is stored in gameChoice.
     *
     *  userChoice takes an array of Strings, options, as an argument and returns the user selected Answer.
     *  Reference to the user's choice is stored in userChoice.
     */
    val gameChoice = getGameChoice(options)
    val userChoice = getUserChoice(options)
}

/*
 *  getGameChoice chooses one of the parameter array, optionsParam, items at random.
 *  getGameChoice has one parameter of the type Array<Sting> and return a String as inferred by the returned result.
 *
 *  getGameChoice function has been simplified into a single line expression as it only has
 *  a single expression and a single return type.
 *
 *  a random number is generated by multiplying a number between 0 and almost 1, Math.random(),
 *  by the size of the array, optionsParam.size .
 *  The result is then rounded into an integer value, .toInt(), which is then used as an index for accessing array.
 */
fun getGameChoice(optionsParam: Array<String>) = optionsParam[(Math.random() * optionsParam.size).toInt()]

fun getUserChoice(optionsParam: Array<String>): String {
    var isValidChoice = false
    var userChoice = ""

    while (!isValidChoice) {
        /*
         *  Asking the user for his answer:
         *
         *  Instead of hard coding the choices, we iterate through the available options.
         *  This is helpful in case new values were added/removed from our Array<String>.
         *  for loop will iterate over the optionsParam values and print them on the screen.
         */
        print("Please choose of the following,")
        for (item in optionsParam) print(" $item")
        print(": ")

        //  reads the user input from output window and stores it in a variable
        val userInput = readLine()

        /*
         *  Validating the user input:
         *  
         *  readLines() returns null value if it's ready a line from a file and it reaches the end of the file.
         *  Despite this not being the case in our program, as we're reading from the output window,
         *  it's a good practice to always validate the user input.
         *
         *  if Statement return true if both the userInput isn't null and its value matches an item within
         *  the passed Array<String> optionsParam.
         *  The expressions within if body are then executed:
         *  isValidChoice is updated to true, so the if statement stops looping.
         *  userInput is verified and a reference to it is stored in variable userChoice
         */
        if (userInput != null && userInput in optionsParam) {
            isValidChoice = true
            userChoice = userInput
        }
        //  if user input didn't pass the above condition, the user will be asked to re-enter his choice
        if (!isValidChoice) println("You must enter a valid choice.")
    }
    // userChoice reference value is updated and returned
    return userChoice
}
```



##### Local Variables:

- only visible inside the function.
- must be locally initialized before they can be used.
- function parameters are the same as local variables
  - they are only visible inside the function.
  - they are automatically initialized, by the invoked function argument(s).
  - can not assign a new value to a function parameter variable, because they are automatically declared as `val`.



##### Loops:

- ###### `while` loop:

  - Runs while a *condition* is true.
  - it **manually** iterates over a range
    - we need to initialize a variable, and
    - increament its value to iterate.

  ```kotlin
  fun main() {
    	var i = 1
      	while (i in 1..5) {
      		println(i)
      		i += 1
        }
  }
  ```

  

- ###### `for` loop: useful when you want to

  -  iterrate over a fixed range of elements, or
  - through every item in an Array, or some other **collections**.
  - ***automatically*** iterates over a range of items/values.
    - no need to initialize variable manually or increament its value for iteration

  - â€‹	We specify the range using the `..` operator.
  - The variable `i` gets created when the loop runs.
  - At the beginning of each loop, the number is assigned to the variable.
  - If the *for* loop only has a single statment, we can make it more conscise: 

  ```kotlin
  fun main() {
      // reads: for each number between 1 and 5 assign the number to variable i and run the body of the loop.
      for (i in 1..5) println(i)  
  }
  ```

  - `..`: *includes* both side of the range: `for (i in 1..5)` 

  - `until`:  *exclude* the last number: `for (i in 1 until 5)` 

  - `downTo`: to reverse the range: `for (i in 5 downTo 1)` // until can also be used here

  - `step`: 
    - both `until` and `downTo` step through the range *one item at a time*. 
    - step allows us to customize the step.
    - `for (i in 1 until 5 step 2)`



##### Looping through the items of an Array:

- In order:

  ```kotlin
  for (items in optionsParam) {
    println(""$item is an item in the array")
  }
  ```

- via the array's indices:

  ```kotlin
  for (index in optionsParam.indices) {
    println("Index $index has the item: $optionsParam[index]")
  }
  ```

- The above loop can be simplified using `.withIndex()`:

  ```kotlin
  for ((index, item) in optionsParam.withIndex()) {
    println("Index $index has item $item")
  }
  ```

  - This will loop through each item of the array:
    - The item's *index* will be assigned to the variable `index`
    - The *item itself* will be assigned to the variable `item`
  



#### Ask the user for their choice:

```kotlin
// Ask the user for their choice:
print("Please pick a choice:")

// Printout the available choices on the same line:
for (item in optionsParam) print(" $item")
println(".")
```



###### Use the readline funciton to read the user's input:

`readLine()` function: 

- reads a line of input from the *Standard Input Stream* (output windows in IDE, in our case)

- Returns a *String* vlaue: the text entered by the user:

  ```kotlin
  val userInput = readLine()
  ```



###### Boolean Expressions:

- `&&`: Both sides of the symbol are true.

- `||`: Either side of the symbol is true. 

- `!=`: Does not equal to

- `!`: Is not

  

###### We need to validate the user's input:

1. Check the user's input isn't *null*
2. Check whether the user's choice is in the options Array.
3. Loop until the user enters a valid choice.

*Already implemented in the full example at the top*
